// Generated by CoffeeScript 2.5.1
(function() {
  var ChainShuttle, FOOToken, TruffleAssert, bridgeConf, erc20Json, should;

  should = require('should');

  TruffleAssert = require('truffle-assertions');

  bridgeConf = require('../env/docker/chainbridge/.config.json');

  erc20Json = require('./resources/ERC20PresetMinterPauser.json');

  ChainShuttle = artifacts.require('ChainShuttle');

  FOOToken = artifacts.require('FOOToken');

  contract('ChainShuttle', function(accounts) {
    var foo, shuttle, taxi;
    shuttle = {};
    foo = {};
    taxi = {};
    beforeEach('setup contracts', async function() {
      shuttle = (await ChainShuttle.deployed());
      foo = (await FOOToken.deployed());
      taxi = new web3.eth.Contract(erc20Json.abi, bridgeConf.chains[0].info.erc20Address);
      await shuttle.setUpBridge(bridgeConf.chains[0].opts.bridge, "0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69500", "0x000000000000000000000000000000f44be64d2de895454c3467021928e55e00");
      return (await shuttle.setUpMirror(1, shuttle.address));
    });
    describe('setUpBridge(_bridge,_erc20HandlerID,_genericHandlerID)', function() {
      it('set up bridge params in contract state', async function() {
        var newAddress, newResourceID;
        await shuttle.setUpBridge(shuttle.address, "0x0000000000000000000000000000000000000000000000000000000000000001", "0x0000000000000000000000000000000000000000000000000000000000000001");
        newAddress = (await shuttle.bridgeAddress());
        newAddress.should.eql(shuttle.address);
        newResourceID = (await shuttle.erc20HandlerID());
        return newResourceID.should.eql("0x0000000000000000000000000000000000000000000000000000000000000001");
      });
      return it('when `_bridge` is not a contract, revert transaction', async function() {
        return (await TruffleAssert.reverts(shuttle.setUpBridge(accounts[0], "0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69500", "0x000000000000000000000000000000f44be64d2de895454c3467021928e55e00")));
      });
    });
    describe('setUpMirror(_destChainID,_mirror)', function() {
      return it('set up cross-chain mirror in contract state', async function() {
        var newAddress;
        await shuttle.setUpMirror(1, shuttle.address);
        newAddress = (await shuttle.mirrorAddress());
        return newAddress.should.eql(shuttle.address);
      });
    });
    describe('setTokenMapping(_mirror)', function() {
      return it('add new mapping in contract state', async function() {
        var mapping;
        await shuttle.setTokenMapping(foo.address, foo.address);
        mapping = (await shuttle.getTokenMapping(foo.address));
        return mapping.should.eql(foo.address);
      });
    });
    return describe('registerTransfer(_to, _token, _amount)', function() {
      it('register a new transfer', async function() {
        var allowedTranfer, amount, result, shuttleBalance, transferAmount;
        amount = 10000;
        await taxi.methods.mint(accounts[0], 1000000).send({
          from: accounts[0]
        });
        await taxi.methods.approve(shuttle.address, amount).send({
          from: accounts[0]
        });
        allowedTranfer = (await taxi.methods.allowance(accounts[0], shuttle.address).call());
        result = (await shuttle.registerTransfer(accounts[0], taxi._address, amount, {
          from: accounts[0],
          value: web3.utils.toWei('0.05', 'ether')
        }));
        transferAmount = (await shuttle.getTransferAmount(accounts[0], accounts[0], taxi._address));
        transferAmount.toNumber().should.eql(amount);
        shuttleBalance = (await taxi.methods.balanceOf(shuttle.address).call());
        Number(shuttleBalance).should.eql(amount);
        return TruffleAssert.eventEmitted(result, 'TransferRegistered', {
          from: accounts[0]
        });
      });
      it('when `_token` is not a contract, revert transaction', async function() {
        return (await TruffleAssert.reverts(shuttle.registerTransfer(accounts[0], accounts[0], 10000)));
      });
      return it('when `msg.sender` did not approve to withdraw `_amount`, revert transaction', async function() {
        return (await TruffleAssert.reverts(shuttle.registerTransfer(accounts[0], taxi._address, 10000)));
      });
    });
  });

}).call(this);
