// Generated by CoffeeScript 2.5.1
(function() {
  var ChainShuttle, FOOToken, should, truffleAssert;

  should = require('should');

  truffleAssert = require('truffle-assertions');

  ChainShuttle = artifacts.require('ChainShuttle');

  FOOToken = artifacts.require('FOOToken');

  contract('ChainShuttle', function(accounts) {
    var foo, shuttle;
    shuttle = {};
    foo = {};
    before('setup contract', async function() {
      shuttle = (await ChainShuttle.deployed());
      foo = (await FOOToken.deployed());
      return (await shuttle.setBridgeAddress(shuttle.address));
    });
    describe('setBrideAddress(_bridge)', function() {
      it('set `bridgeAddress` in contract state', async function() {
        var newAddress;
        await shuttle.setBridgeAddress(shuttle.address);
        newAddress = (await shuttle.bridgeAddress());
        return newAddress.should.eql(shuttle.address);
      });
      return it('when `_bridge` is not a contract, revert transaction', async function() {
        return (await truffleAssert.reverts(shuttle.setBridgeAddress(accounts[0])));
      });
    });
    describe('setMirrorAddress(_mirror)', function() {
      return it('set `mirrorAddress` in contract state', async function() {
        var newAddress;
        await shuttle.setMirrorAddress(shuttle.address);
        newAddress = (await shuttle.mirrorAddress());
        return newAddress.should.eql(shuttle.address);
      });
    });
    describe('setTokenMapping(_mirror)', function() {
      return it('add new mapping in contract state', async function() {
        var mapping;
        await shuttle.setTokenMapping(foo.address, foo.address);
        mapping = (await shuttle.getTokenMapping(foo.address));
        return mapping.should.eql(foo.address);
      });
    });
    return describe('registerTransfer(_to, _token, _amount)', function() {
      it('register a new transfer', async function() {
        var allowedTranfer, amount, result, shuttleBalance, transferAmount;
        amount = 10000;
        await foo.approve(shuttle.address, amount);
        allowedTranfer = (await foo.allowance(accounts[0], shuttle.address));
        allowedTranfer.toNumber().should.eql(amount);
        result = (await shuttle.registerTransfer(accounts[0], foo.address, amount));
        shuttleBalance = (await foo.balanceOf(shuttle.address));
        shuttleBalance.toNumber().should.eql(amount);
        transferAmount = (await shuttle.getTransferAmount(accounts[0], accounts[0], foo.address));
        transferAmount.toNumber().should.eql(amount);
        return truffleAssert.eventEmitted(result, 'TransferRegistered', {
          from: accounts[0]
        });
      });
      it('when `_token` is not a contract, revert transaction', async function() {
        return (await truffleAssert.reverts(shuttle.registerTransfer(accounts[0], accounts[0], 10000)));
      });
      return it('when `msg.sender` did not approve to withdraw `_amount`, revert transaction', async function() {
        await foo.approve(shuttle.address, 0);
        return (await truffleAssert.reverts(shuttle.registerTransfer(accounts[0], foo.address, 10000)));
      });
    });
  });

}).call(this);
